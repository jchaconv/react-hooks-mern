
Instalaciones necesarias:
https://gist.github.com/Klerith/4a4abfd88a88b2d1f16efd95fea41362


*********************************
SECCION 2 : Introducción a React
*********************************

Se creó 01-intro-react

Se agregó:
https://gist.github.com/Klerith/b0111f52ba16451d095f38d4c995605b

así de sencillo se tiene un app con react

Babel permite que React use código de js y es compatible para todos los browsers

Ir al engranaje de la consola y marcar "selected context only"

undefined.length => es un error crítico, para evitarlo:
resApi.personajes?.length

**********************************************
SECCION 3 : Introducción a Javascript Moderno
**********************************************

-Bash en /d/cursos-udemy/react-hooks-mern:
npx create-react-app intro-javascript
-renombrar a 02-intro-javascript y llevar a bash:
npm start

const => no cambian
let => variable

****

template string:
`` => en mi teclado sale con Alt Gr + tecla a la izq de enter y arriba de shift
con backticks puedo llamar variables y funciones

****

Objetos literales:

const persona = {
    nombre: 'Julio',
    apellido: 'Chacon',
    edad: 101,
    direccion: {
        ciudad: 'Lima',
        zip: 2002,
        lat: 14.23332,
        lng: 23.56211
    }
};

si quiero hacer una copia del objeto debo usar el operador spread
para no hacer solo una copia de la referencia en memoria:

const persona2 = { ...persona };


****

Arreglos:

También se usa spread:
let arreglo2 = [...arreglo, 5]

la función map crea un nuevo arreglo y ejecuta una función

****

Funciones:

Poner los parentesis para retornar un objeto:
const getUser = () => ({
    uid: 'ABC256',
    username: 'chearee'
})

****

Desestructuración de obj y arr:

para hacerlo con obj anidados:
const { nombreClave, anios, latlng } = retornaPersona4( persona );
const {lat, lng } = latlng;

****

Import, export y funciones comunes de arreglos

https://gist.github.com/Klerith/4aeb99d31aedbc29ff4d54bbb77d2d7f

abrir y cambiar de pestaña, escribir el nombre del obj y se importará autom

https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find


Cuando la export es default no necesita llaves:

export const owners = ['DC', 'Marvel'];
export default heroes;

import heroes, {owners} from "./data/heroes";

Otra manera de exportar:

const owners = ['DC', 'Marvel'];

export {
    heroes as default,
    owners
}

****

Promesas

al resolve() se le pueden enviar valores y luego se llama con then()
de la misma manera pasa con reject() y catch()

para que una función pueda tener el then() y catch() es necesario que retornen
una promesa


****

Fetch API

Se vieron promesas encadenadas
y manejo de json retornado por un api

****

Async - Await

Cuando se agrega async el retorno de la función se convierte en una Promesa
por cada Promise como response se agrega un await
poner todo dentro de un try-catch

****

Operador Ternario

Dos maneras de usarlo, la última es para el if corto

const activo = true;

//const mensaje = ( activo ) ? 'Activo' : 'Inactivo';
const mensaje = ( activo ) && 'Activo';


***********************************
SECCION 4 : Primeros pasos en React
***********************************

-cmd(interactivo) en /d/cursos-udemy/react-hooks-mern:
npm install -g yarn
yarn create vite
name: counter-app
seleccionar react -> js -> cambiar nombre a la carpeta
entrar a la ruta de la carpeta y ejecutar: yarn install

regresar a la carpeta padre y ejecutar:
npx create-react-app counter-app

ver diferencias entre proyectos

ejecutar: yarn dev

rafc para crear componentes


********

Comunicación entre Props

desde la pestaña Components de la consola de chrome puedo probar las props
puse title: "Hola" y enter, se ve el cambio

para poner props por defecto en caso llegue vacío:
export const FirstApp = ({ title = 'Hola soy Julio', subtitle, code }) ...

para enviar un número:
    <FirstApp
        title="Hola, soy Goku"
        subtitle={123}
        code={456}
    />

********

PropTypes: FirstApp.jsx

yarn add prop-types

Sirven para especificar las props del componente y sus tipos de datos

para enviar un boolean solo es necesario enviar el nombre del propType:
<FirstApp title />

Para definirlas se pone al final:

FirstApp.propTypes = {
    title: PropTypes.string.isRequired,
    subtitle: PropTypes.number.isRequired,
    code: PropTypes.number
}

********

DefaultProps : FirstApp.jsx

para enviar valores por defecto y son tomados antes que las propTypes

FirstApp.defaultProps = {
    title: 'No hay titulo',
    subtitle: 'No hay subtitulo',
    username: 'Julio Chacon',
    code: 240588
}

********

Hook - useState :: CounterApp.jsx

const [counter, setCounter ] = useState(value);

value viene del componente padre

si queremos modificar ese valor hay que llamar a setCounter()

setCounter( counter + 1 );

también se puede escribir así:

setCounter( (c) => c + 1 );

Cada vez que hay un cambio en el estado el componente se vuelve a ejecutar,
lo comprobamos poniendo un log al comienzo:
console.log('RENDER');

Programar ordenandamente es clave porque si hubiera una invocación a un api
se estaría ejecutando una y otra vez

**************************************
SECCION 6 : GifExpertApp - Aplicacion
**************************************

ir a carpeta principal:
yarn create vite
name: gif-expert-app

entrar a la carpeta del proyecto:
yarn install
yarn dev

estilos css:
https://gist.github.com/Klerith/e4fca6ac127ccb9abd1e8ad77fcd52f1
ponerlos de manera global importando en el main

Cuando se hace un recorrido de arreglo se debe proporcionar un "key" prop unico
categories.map( category => {
    return <li key={ category }>{category}</li>
})

Se pone event.preventDefault(); en el onSubmit del form para evitar que recargue
el navegador


********

Hooks - useEffect

para evitar que react redibuje el componente una y otra vez
se comento el Stricness para evitar un log de consola(solo afecta en desa no en prod)

para evitar que se ejecute una y otra vez getGifs:

este hook sirve para que cuando cambie el estado se ejecute un efecto secundario

useEffect( () => {

    getGifs(category);

}, [])

en el arreglo están las dependencias, así como está funcionó correctamente

********

customHook - useFetchGifs

crearlo con rafc ya que es un componente pero no retorna jsx sino un objeto
si las propiedas en el return tienen el mismo nombre(clave,valor) solo enviarlas así:
return {
    images,
    isLoading
}

********

Para mostrar jsx condicional:
{
    isLoading
    ? ( <h2>Cargando ...</h2> )
    : null
}

otra manera más corta:
{
    isLoading && ( <h2>Cargando ...</h2> )
}


******************************************
SECCION 9 : Profundizando hooks generales
******************************************


yarn create vite
name: hook-app
renombrar a 05-hook-app
yarn

borrar todo excepto el main.jsx y crear un index.css


se agregó bootstrap con esto en el index.html:
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">

********

useState :: CounterApp.jsx

este hook también puede almacenar el estado de un objeto

const [ state, setCounter] = useState({
        counter1: 10,
        counter2: 20,
        counter3: 30
});

si quiero cambiar el estado de algún counter con el setCounter debo 
especificar cada propiedad del objeto, para ello se recomienda usar spread

onClick={ () => setCounter({
    ...state,
    counter1: counter1 + 1
}) }

********

customHook - useCounter.js

puedo retornar valores y funciones para cambiar el estado:

return {
    counter,
    increment,
    decrement,
    reset,
}

puedo consumir así :: CounterWithCustomHook.jsx

const { counter, increment, decrement, reset } = useCounter();

Si se necesita enviar algún valor a las funciones del customHook se debe hacer así:
<button 
    onClick={ () => increment(2) }
>+1</button>

haciendo esto también se evita el object Object

********

useEffect :: SimpleForm.jsx

En esta función se recibe el event, al cual desestructuramos con {target}, asimismo
se obtiene {name, value} del target 
y está reconociendo el nombre del input que está cambiando y le setea el valor
con [name]: value

const onInputChange = ({ target }) => {
    const { name, value } = target;
    console.log(name, value);
    setFormState({
        ...formState,
        [ name ]: value
    });
}

en cuanto a las dependencias del hook, cuando solo se necesita que se ejecute la función
al levantar el componente por primera vez, se deja el arreglo vacío, así:
useEffect(() => {
    console.log('useEffect!');
}, []);

Se recomienda tener useEffect por cada estado que cambie, por ejemplo:
useEffect(() => {
    console.log('useEffect!');
}, []);

useEffect(() => {
    console.log('formState changed!');
}, [formState]);

useEffect(() => {
    console.log('email changed!');
}, [email]);


********

useEffect unmount - Cleanup :: Message.jsx

para ver la opción del retorno del useEffect
se usa cuando el componente se levanta y se destruye:

useEffect(() => {

    console.log('Message Mounted');

    return () => {
        console.log('Message Unmounted');
    }
}, [])

Es necesario hacer la limpieza en el return como en el ejemplo:
useEffect(() => {

    const onMouseMove = ({ x, y }) => {
        setCoords({ x, y});
    }
    
    window.addEventListener( 'mousemove', onMouseMove);

    return () => {
        window.removeEventListener( 'mousemove', onMouseMove);
    }
}, [])

********

customHook - useForm.js

Para hacer el componente genérico y poder invocar sus propiedades ahorrando una línea
para la Desestructuración. Se puede hacer lo siguiente:

Agregar ...formState y de esa manera estarán llegando todas las propiedades que tenga el formulario

return {
   ...formState,
   formState,
   onInputChange
}

En FormWithCustomHook.jsx:

const { formState, onInputChange, username, email, password } = useForm({
    username: '',
    email: '',
    password: ''
});

********

archivo de barril para reducir imports
se creó /hooks/index.js

export * from './useCounter';
export * from './useFetch';
export * from './useForm';

Las imports quedarían así:
import { useCounter, useFetch } from '../hooks';


********

hooks :: useRef => FocusScreen.jsx

Sirve para manipular un objeto en especifico utilizando su referencia
y de esa manera no se dibuja el componente otra vez

const inputRef = useRef();

const onClick = () => {
    inputRef.current.select();
}


********

funcion memo :: Memorize.jsx

Se ve que un componente hijo se crea otra vez cuando el padre tiene un cambio
en otro componente hijo. En este ejemplo se vio lo sgte:

<Memorize>
    <Small />

    <button {show}>

</Memorize>

Cuando había un cambio en el state show se disparaba también el Small
Para solucionar esto podemos usar la funcion memo de react.

Esta manera es poco usada pero sirve. Se debe englobar el código en paréntesis luego
de la palabra memo.

import { memo } from 'react';

export const Small = memo(({ value }) => {

    console.log('Small dibujando ...')

    return (
        <small>{ value }</small>
    )
})

Esta forma es más usual:

import React from 'react'

export const Small = React.memo(({ value }) => {

    console.log('Small dibujando ...')

    return (
        <small>{ value }</small>
    )
})

Así ya no se dispara el componente Small :)

********

hook - useMemo :: MemoHook.jsx

El hook guarda en memoria el valor de la función y solo se volverá a procesar
cuando haya un cambio en el arreglo de dependencias, en este caso "counter"

const memorizedValue = useMemo(() => heavyStuff(counter), [counter]);

<h4> { memorizedValue } </h4>

Al usar el hook ya no se muestra el log del heavyStuff

********

hook - useCallback :: CallbackHook.jsx

Cuando se envía una función a otro componente este no la puede memorizar así tenga 
React.memo porque cada vez que se crea apunta a un espacio de memoria distinto

Una vez agrego el sgte codigo:

const incrementFather = useCallback(
    () => {
        setCounter( (value) => value +1 );
    },
    [],
);

De esta manera queda memorizada incrementFather y ShowIncrement la puede reconocer como
la misma funcion inicial

Se usa así: setCounter( (value) => value +1 );
porque al mandarle el callback está tomando el valor inicial de una manera más forsoza y lo suma

Si se necesita mandar argumentos:

const incrementFather = useCallback(
    ( cinco ) => {
        setCounter( (value) => value + cinco );
    },
    [],
);


En ShowIncrement:
<button
    className='btn btn-primary'
    onClick={ () => {
        increment(5);
    }}
>


********




********


